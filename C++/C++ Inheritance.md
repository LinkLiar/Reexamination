- 基类 & 派生类

  一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

  ```
  class derived-class: access-specifier base-class
  ```

  其中，访问修饰符 access-specifier 是 **public、protected** 或 **private** 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。
  
- **6. “引用”与多态的关系？**

  引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例



一个C++的空类，编译器会加入哪些默认的成员函数

**·默认构造函数和拷贝构造函数**

**·析构函数**

**·赋值函数（赋值运算符）**

**·取值函数**



**注意：构造函数可以被重载，可以多个，可以带参数；**

**析构函数只有一个，不能被重载，不带参数**

注意：一个类只能有一个默认构造函数！也就是说上述两种方式不能同时出现，一般选择 testClass(); 这种形式的默认构造函数 ；

只要程序员定义了构造函数，编译器就不会再提供默认构造函数了，所以，程序员最好再手动定义一个默认构造函数

定义默认构造函数有两种方式，如上述代码展示的，一是定义一个无参的构造函数，二是定义所有参数都有默认值的构造函数 ；

**在C++中，3种对象需要复制，此时拷贝构造函数会被调用**

**1）一个对象以值传递的方式传入函数体**

**2）一个对象以值传递的方式从函数返回**

**3）一个对象需要通过另一个对象进行初始化**



浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，

深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存。



### 默认拷贝构造函数

很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值。

出现这些问题最根本就在于在复制对象时，计数器没有递增，我们重新编写拷贝构造函数



> 当出现类的等号赋值时，会调用拷贝函数，在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象。所以这时必须采用深拷贝。

> 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。



### C++构造函数以及析构函数的若干问题

- Q1：构造函数能否重载，析构函数能否重载，为什么？
   A1：构造函数可以，析构函数不可以。
- Q2：析构函数为什么一般情况下要声明为虚函数？
   A2：虚函数是实现多态的基础，当我们通过基类的指针是析构子类对象时候，如果不定义成虚函数，那只调用基类的析构函数，子类的析构函数将不会被调用。如果定义为虚函数，则子类父类的析构函数都会被调用。
- Q3：什么情况下必须定义拷贝构造函数？
   A3：当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。例如大的堆栈数据拷贝。如果定义了拷贝构造函数，那也必须重载赋值操作符。



### 防止默认拷贝发生

通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个**私有拷贝构造函数**。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。



 父类子类指针函数调用注意事项

 1，如果以一个基础类指针指向一个衍生类对象(派生类对象)，
 那么经由该指针只能访问基础类定义的函数（静态联翩）

 2，如果以一个衍生类指针指向一个基础类对象，必须先做强制转型动作，这种做法很危险，也不符合生活习惯，在程序设计上也会给程序员带来困扰。

 3，如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，
 到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。



 虚拟函数就是为了对“如果你以一个基础类指针指向一个衍生类对象，那么通过该指针，你只能访问基础类定义的成员函数”这条规则反其道而行之的设计。

　　**对象不存在，且没用别的对象来初始化，就是调用了构造函数；**

​        **对象不存在，且用别的对象来初始化，就是拷贝构造函数（上面说了三种用它的情况！）**

​        **对象存在，用别的对象来给它赋值，就是赋值函数。**

**拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。**



lib是静态库，dll一般是动态链接库（也有可能是别的）

比如要编译个exe，lib在编译的时候就会被编译到exe里，作为程序的一部分

而dll是不被编译进去，是运行的时候才调入的（可能是exe刚运行就调入，也可能运行了一半才调入）

用法，lib需要个.lib文件和一个.h文件，程序正常使用.h的函数，在链接选项里加入.lib文件就ok

dll用法有2种：

一是 .h + .lib + .dll的，用法和前面一样，中间的lib是个中转，运行的时候会调用dll
二是：直接用dll，需要知道dll的函数定义

https://github.com/labuladong/fucking-algorithm

https://github.com/SharingSource/LogicStack-LeetCode
